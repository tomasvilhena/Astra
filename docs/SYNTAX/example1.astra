entry "main";
// ==============================
// Astra Programming Language Syntax Demo
// ==============================

// Single-line comment

/* Multi-line comment */
// ------------------------------
// include
// ------------------------------
// Allows importing libraries.
// Libraries are written in Astra syntax as well.
// A library cannot define an entry point (no main). #include "std.astra" #include "math.astra"

// ------------------------------
// Functions
// ------------------------------
// Functions are declared with the fn keyword.
// Syntax: fn name(params): return_type { ... }
//
// Return type can be any type (number, string, etc.) or void if nothing is returned.

fn add(a: number, b: number): number
{
  return a + b;
  // explicit return
}

// Default parameter values are supported using = inside the parameter list.
fn greet(name: string = "World"): void
{
  println("Hello, {}", name);
}
// ------------------------------
// Arrays
// ------------------------------
fn array_demo(): void
{
  let nums: array<number> = [1, 2];

  nums.push_end(3); // adds value to the end of an array

  nums.push_start(0); // adds value to the beginning of the array

  nums.remove(0); // removes the number at the specified position

  let more: array<number> = [4, 5];

  nums.merge(more); // appends the "more" array to the end of the nums array

  println("Array size: {}", nums.length()); // provides the length of the array
}

// ------------------------------
// Strings
// ------------------------------
fn string_demo(): void
{
  let text: string = "hello";
  let more: string = " world";

  text.uppercase(); // makes text string uppercase
  text.lowercase(); // makes text string lowercase

  text.expand(more); // adds the "more" string to the "text" string

  text = text.trim(); // removes whitespace at beginning and end

  if (text.contains("world")) // returns true if the substring exists
  {
    println("Text: {}", text);
  }
}

// ------------------------------
// Input and Matching
// ------------------------------
fn input_demo(): void
{
  println("Enter your age: ");

  let input: string = read(); // reads input from the user
  let age: number = input.parse_int(); // converts the string to an integer

  // Match is used for branching on values
  match age
  {
    18 => {
      println("You are 18!");
    }

    21 => {
      println("You are 21!");
    }

    _ => {
      println("Age: {}", age);
    } // "_" or "default" matches anything else

  }
}

// ------------------------------
// Loops
// ------------------------------
fn loops_demo(): void
{
  // repeat loop with counts
  repeat 5 as i // repeats 5 times: i = 0..4
  {
    print("{}", i);
  }

  repeat 6 as i // repeats 6 times: i = 0..5
  {
    print("{}", i);
  }

  // Iterating arrays by index
  let book_collection: array<string> = ["lord of the rings", "hobbit"];
  repeat book_collection.length() as i
  {
    print("{}", book_collection[i]);
  }

  // Iterating arrays by value
  repeat book_collection.length() as i
  {
    let book: string = book_collection[i];
    print("{}", book);
  }

  // while loop
  let x: number = 0;

  while (x < 3)
  {
    println("While: {}", x);
    x += 1;

    if (x == 2)
    {
      continue;
    } // skip rest of this iteration
  }
}

// ------------------------------
// Operators
// ------------------------------
fn operators_demo(): void
{
  let a: number = 10;
  let b: number = 3;

  // Arithmetic
  println("Sum: {}", a + b);
  println("Sub: {}", a - b);
  println("Mul: {}", a * b);
  println("Div: {}", a / b);
  println("Mod: {}", a % b);
  println("Exponentiation: {}", a*);

  // example custom operator
  // Boolean logic
  let flag1: bool = (a > b) && (b < 5);
  let flag2: bool = (a > b) AND (b < 5);

  // keyword alternative
  let flag3: bool = (a > b) || (b < 5);
  let flag4: bool = (a > b) OR (b < 5);
  println("Flag: {}", flag1); }

  // ------------------------------
  // Error Handling (TRY/ON)
  // ------------------------------
  // try { ... } on { ... } executes the try block,
  // and if an error occurs, runs the on block.
  // It can be used for statements (no return value required).

  fn error_handling_demo(): void
  {
    try
    {
      println("Trying risky code...");
      let x: number = "oops".parse_int();
      // will fail
    } on
    {
      println("Recovering from error");
    }
  }

  // ------------------------------
  // Entry Point
  // ------------------------------

  fn main(): void
  {
    println("=== Astra Language Syntax Demo ===");

    greet(); // default parameter ("World")

    greet("Astra"); // explicit argument

    println("Add: {}", add(5, 7));
    array_demo();

    string_demo();

    input_demo();

    loops_demo();

    operators_demo();

    error_handling_demo();

    clear(); // clears the screen

    println("Done.");
  }
